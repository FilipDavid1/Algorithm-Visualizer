<resources>
    <string name="app_name">Algorithm Visualizer</string>
    <string name="sorting_algorithms_title">Sorting Algorithms</string>
    <string name="sorting_algorithms_desc">Try different sorting algorithms and see how they work step by step.</string>
    <string name="searching_algorithms_title">Searching Algorithms</string>
    <string name="searching_algorithms_desc">Find values in arrays using efficient search methods.</string>
    <string name="number_of_algorithms">Number of available algorithms:</string>
    <string name="show_button_text">SHOW</string>

    <!-- Algorithm Names -->
    <string name="bubble_sort">Bubble Sort</string>
    <string name="selection_sort">Selection Sort</string>
    <string name="insertion_sort">Insertion Sort</string>

    <!-- Algorithm Descriptions -->
    <string name="bubble_sort_desc">Bubble Sort repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed.</string>
    <string name="selection_sort_desc">Selection Sort divides the array into a sorted and unsorted region, repeatedly finding the minimum element from the unsorted region and adding it to the sorted region.</string>
    <string name="insertion_sort_desc">Insertion Sort builds the final sorted array one item at a time, by repeatedly inserting a new element into the sorted portion of the array.</string>

    <!-- Sorting Screen -->
    <string name="pick_algorithm">Pick sorting algorithm:</string>
    <string name="press_sort_to_start">Press sort to start %1$s algorithm</string>
    <string name="timer_display">Time: %.2f seconds</string>
    <string name="timer_zero">Time: 0.00 seconds</string>
    <string name="info_button_hint">Click to dive into logic, code &amp; O(n)</string>
    <string name="sort_button">SORT</string>
    <string name="stop_button">STOP</string>
    <string name="reset_button">RESET</string>
    <string name="back">Back</string>

    <!-- Algorithm Info Screen -->
    <string name="time_complexity">Time Complexity</string>
    <string name="space_complexity">Space Complexity</string>
    <string name="algorithm_logic">Algorithm Logic</string>
    <string name="best_use_cases">Best Use Cases</string>

    <!-- Time Complexities -->
    <string name="bubble_sort_time">Best: O(n)\nAverage: O(n²)\nWorst: O(n²)</string>
    <string name="selection_sort_time">Best: O(n²)\nAverage: O(n²)\nWorst: O(n²)</string>
    <string name="insertion_sort_time">Best: O(n)\nAverage: O(n²)\nWorst: O(n²)</string>

    <!-- Space Complexities -->
    <string name="bubble_sort_space">O(1)</string>
    <string name="selection_sort_space">O(1)</string>
    <string name="insertion_sort_space">O(1)</string>

    <!-- Algorithm Logic Steps -->
    <string name="bubble_sort_logic">1. Start with the first element\n2. Compare with next element\n3. Swap if needed\n4. Move to next pair\n5. Repeat until no swaps needed</string>
    <string name="selection_sort_logic">1. Find minimum in unsorted region\n2. Swap with first unsorted element\n3. Expand sorted region\n4. Repeat until array is sorted</string>
    <string name="insertion_sort_logic">1. Start with second element\n2. Compare with previous elements\n3. Shift larger elements right\n4. Insert in correct position\n5. Repeat for all elements</string>

    <!-- Use Cases -->
    <string name="bubble_sort_uses">• Small datasets\n• Nearly sorted arrays\n• Educational purposes</string>
    <string name="selection_sort_uses">• Small datasets\n• Memory constrained systems\n• When writes are expensive</string>
    <string name="insertion_sort_uses">• Small datasets\n• Nearly sorted arrays\n• Online sorting (stream of data)</string>

    <!-- Sorting Algorithm Messages -->
    <string name="comparing_elements">Comparing elements %1$d and %2$d</string>
    <string name="swapped_elements">Swapped elements %1$d and %2$d</string>
    <string name="pass_completed">Pass %1$d completed</string>
    <string name="moved_smallest_element">Moved smallest element %1$d to position %2$d</string>
    <string name="inserting_element">Inserting element %1$d into sorted portion</string>
    <string name="shifted_element">Shifted element %1$d right</string>
    <string name="inserted_element">Inserted %1$d at correct position</string>
    <string name="merging_subarrays">Merging subarrays from index %1$d to %2$d</string>
    <string name="placed_smaller_element">Placed smaller element %1$d at position</string>
    <string name="copying_remaining_elements_from_left_subarray">Copying remaining elements from left subarray</string>
    <string name="copying_remaining_elements_from_right_subarray">Copying remaining elements from right subarray</string>
    <string name="dividing_array">Dividing array from index %1$d to %2$d</string>
    <string name="single_element_at_index">Single element at index %1$d is sorted</string>
    <string name="sorting_completed">Sorting completed!</string>
    <string name="press_search_to_start">Press search to start %1$s algorithm</string>

    <!-- Searching Algorithms -->
    <string name="searching_algorithms">Searching Algorithms</string>
    <string name="linear_search">Linear Search</string>
    <string name="binary_search">Binary Search</string>
    <string name="jump_search">Jump Search</string>
    <string name="insert_search_number">Insert number you want to search</string>
    <string name="search">Search</string>
    <string name="stop">Stop</string>
    <string name="reset">Reset</string>
    <string name="algorithm_info">Click to dive into logic, code &amp; O(n)</string>
    <string name="comparing_with_target">Comparing %1$d with target %2$d</string>
    <string name="found_target_at_index">Found %1$d at index %2$d</string>
    <string name="target_not_found">Target %1$d not found in the array</string>
    <string name="searching_left_half">Searching in the left half</string>
    <string name="searching_right_half">Searching in the right half</string>
    <string name="jumping_to_block">Jumping to block %1$d</string>
    <string name="linear_scanning">Linear scanning at index %1$d</string>
    <string name="time_elapsed">Time: %.1fs</string>

    <!-- Searching Algorithm Descriptions -->
    <string name="linear_search_desc">Linear Search sequentially checks each element in the array until a match is found or the end of array is reached.</string>
    <string name="binary_search_desc">Binary Search repeatedly divides the sorted array in half and compares the middle element with the target value.</string>
    <string name="jump_search_desc">Jump Search works on sorted arrays by jumping fixed steps to find a block where the element may be present, then performing linear search.</string>

    <!-- Searching Time Complexities -->
    <string name="linear_search_time">Best: O(1)\nAverage: O(n)\nWorst: O(n)</string>
    <string name="binary_search_time">Best: O(1)\nAverage: O(log n)\nWorst: O(log n)</string>
    <string name="jump_search_time">Best: O(1)\nAverage: O(√n)\nWorst: O(√n)</string>

    <!-- Searching Space Complexities -->
    <string name="linear_search_space">O(1)</string>
    <string name="binary_search_space">O(1)</string>
    <string name="jump_search_space">O(1)</string>

    <!-- Searching Algorithm Logic Steps -->
    <string name="linear_search_logic">1. Start from first element\n2. Compare with target value\n3. If match found, return index\n4. If not found, move to next element\n5. Repeat until found or end reached</string>
    <string name="binary_search_logic">1. Find middle element\n2. Compare with target value\n3. If match found, return index\n4. If target is smaller, search left half\n5. If target is larger, search right half</string>
    <string name="jump_search_logic">1. Choose block size (√n)\n2. Jump fixed steps ahead\n3. Find block where element may exist\n4. Perform linear search in that block\n5. Return if found, else not present</string>

    <!-- Searching Algorithm Use Cases -->
    <string name="linear_search_uses">• Unsorted arrays\n• Small datasets\n• Simple implementation needed</string>
    <string name="binary_search_uses">• Sorted arrays\n• Large datasets\n• Frequent searches needed</string>
    <string name="jump_search_uses">• Sorted arrays\n• Skip unnecessary comparisons\n• Better than linear for medium-sized arrays</string>

    <!-- Step Mode -->
    <string name="step_mode">Step Mode</string>
    <string name="step_progress">Step %1$d of %2$d</string>
    <string name="previous_step">Previous Step</string>
    <string name="next_step">Next Step</string>
    <string name="step_completed">Step completed</string>
    <string name="step_started">Step started</string>
    <string name="step_mode_ready">Steps collected. Use arrows to navigate.</string>
</resources>